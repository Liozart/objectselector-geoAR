<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Object selector</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="style/style.css" type="text/css">
</head>
<body>
<div id="info">
    <a href="javascript:control.setMode( 'translate' );">"W" translate</a> |
    <a href="javascript:control.setMode( 'rotate' );">"E" rotate</a> |
    <a href="javascript:control.setMode( 'scale' );">"R" scale</a> |
    <a href="javascript:control.setSpace( control.space === 'local' ? 'world' : 'local' );">
        "Q" toggle world/local space</a><br />
    <a href="javascript:switchObjectControl();">"T" switch object control</a> |
    Hold "Ctrl" down to snap to grid |
    <a href="javascript:removeObject();">"X" remove</a>
</div>
<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/TransformControls.js"></script>
<script src="js/GLTFLoader.js"></script>
<script src="js/OBJLoader.js"></script>
<script src="js/FBXLoader.js"></script>
<script src="js/GeometryUtils.js"></script>
<script src="js/inflate.min.js"></script>
<script src="js/MTLLoader.js"></script>

<div id="panel" class="container">
    <h3>
        Importer FBX, OBJ ou glTF/glb
        <button id="importWarningButton" type="button" class="btn btn-warning btn-sm" onclick="toggleImportWarningPopover();">
            Warning
        </button>
    </h3>
    <div id="dropZoneObject" ondrop="dropHandlerObject(event);" ondragover="dragOverHandlerObject(event);"
         ondragleave="dragLeaveHandlerObject();">
        <p id="dropTextObject">Glissez et déposez les fichiers ici (Modèle et textures)</p>
    </div>

    <h3>Ajouter forme</h3>
    <button onclick="addCube();">Cube</button>
    <button onclick="addPlane();">Plan</button>
    <button onclick="addCylinder();">Cylindre</button><br/>

    <h5>Modifier couleur</h5>
    <input type="color" id="objColor" name="objColor"
           value="#00ff00" onchange="changeColor();">
    <label for="objColor">Couleur</label>

    <h5>Modifier transparence</h5>
    0<input type="range" id="objOpacity" min="0" max="1" step="0.0001"
            value="#00ff00" oninput="changeOpacity();">1
    <label for="objOpacity">Opacité</label>

    <h5>Importer texture</h5>
    <div id="dropZoneTexture" ondrop="dropHandlerTexture(event);" ondragover="dragOverHandlerTexture(event);"
         ondragleave="dragLeaveHandlerTexture();">
        <p id="dropTextTexture">Glissez et déposez le fichier jpg ou png</p>
    </div>

    <h3>Ajouter texte</h3>
    <label for="fonts">Police</label>
    <select id="fonts" onchange="changeFont();">
        <option value="helvetiker">helvetiker</option>
        <option value="optimer">optimer</option>
        <option value="gentilis">gentilis</option>
        <option value="droid_sans">droid sans</option>
        <option value="droid_serif">droid serif</option>
    </select>
    <input type="checkbox" id="fontWeight" onchange="changeFontWeight();"> Gras<br/>
    <label for="textToAdd">Texte</label>
    <input type="text" id="textToAdd">
    <button onclick="addText();">Ajouter</button><br/>
    <input type="color" id="textColor" name="objColor"
           value="#ff0000">
    <label for="textColor">Couleur</label>
    <input type="color" id="textColorOut" name="objColor"
           value="#0000ff">
    <label for="textColorOut">Couleur contours</label>
    <h5>Importer police
        <button id="importFontWarningButton" type="button" class="btn btn-warning btn-sm" onclick="toggleImportFontWarningPopover();">
            Warning
        </button>
    </h5>
    <div id="dropZoneFont" ondrop="dropHandlerFont(event);" ondragover="dragOverHandlerFont(event);"
         ondragleave="dragLeaveHandlerFont();">
        <p id="dropTextFont">Glissez et déposez le fichier JSON</p>
    </div>
</div>

<script>
    var camera, scene, renderer, control, orbit, light;
    var objects = [];
    var objects_count = 0;
    var selected_object = null;
    var fontName = "helvetiker", fontWeight = "regular" ;
    var lastUploadedObjectName = null;

    const storeFileURL = "storeFile.php";
    const removeFileURL = "removeFile.php";
    const storeFontURL = "storeFont.php";
    const removeFontsURL = "removeFonts.php";

    init();
    render();

    //------------------------------------------------------Init & Render------------------------------------------------------
    /*
     * Initalization function
     */
    function init() {
        //Create renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( (window.innerWidth / 2), (window.innerHeight - 20) );
        document.body.appendChild( renderer.domElement );
        //settings for gltf loading
        //renderer.gammaOutput = true;
        //renderer.gammaFactor = 2.2;

        //Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xbfbfbf );
        scene.add( new THREE.GridHelper( 1000, 10 ) );

        //Create camera
        camera = new THREE.PerspectiveCamera( 50, (window.innerWidth / 2) / (window.innerHeight - 20), 1, 5000 );
        camera.position.set( 1000, 500, 1000 );
        camera.lookAt( 0, 200, 0 );

        //Create light
        light = new THREE.DirectionalLight( 0xffffff, 2 );
        light.position.set( 1, 1, 1 );
        scene.add( light );

        //Create space controls
        orbit = new THREE.OrbitControls( camera, renderer.domElement );
        orbit.update();
        orbit.addEventListener( 'change', render );

        //Create object controls
        control = new THREE.TransformControls( camera, renderer.domElement );
        control.addEventListener( 'change', render );
        control.addEventListener( 'dragging-changed', function ( event ) {
            orbit.enabled = ! event.value;
        } );
        scene.add( control );

        //Object controls modes
        window.addEventListener( 'keydown', function ( event ) {
            switch ( event.keyCode ) {
                case 81: // Q
                    control.setSpace( control.space === "local" ? "world" : "local" );
                    break;
                case 17: // Ctrl
                    control.setTranslationSnap( 20 );
                    control.setRotationSnap( THREE.Math.degToRad( 15 ) );
                    break;
                case 87: // W
                    control.setMode( "translate" );
                    break;
                case 69: // E
                    control.setMode( "rotate" );
                    break;
                case 82: // R
                    control.setMode( "scale" );
                    break;
                case 85: // T
                    switchObjectControl();
                    break;
                case 88: // X
                    removeObject();
                    break;
            }
        } );
        window.addEventListener( 'keyup', function ( event ) {
            switch ( event.keyCode ) {
                case 17: // Ctrl
                    control.setTranslationSnap( null );
                    control.setRotationSnap( null );
                    break;
            }
        } );
    }

    /*
     * Render function
     */
    function render() {
        //requestAnimationFrame( render );
        renderer.render( scene, camera );
    }

    //------------------------------------------------------Basics objects------------------------------------------------------
    /*
     * Add a new cube to the scene
     */
    function addCube() {
        var color = new THREE.Color();
        color.setHex("0x" + ($("#objColor").val()).replace("#", ""));
        var geometry = new THREE.BoxGeometry(100, 100, 100);
        var material = new THREE.MeshLambertMaterial( { color: color,
            transparent: true, opacity: 1.0} );
        var cube = new THREE.Mesh( geometry, material );
        cube.castShadow = true;
        cube.receiveShadow = true;
        objects[objects_count] = cube;
        selected_object = objects_count;
        objects_count++;
        scene.add( cube );
        control.attach( cube );
        render();
    }

    /*
     * Add a new plane to the scene
     */
    function addPlane() {
        var color = new THREE.Color();
        color.setHex("0x" + ($("#objColor").val()).replace("#", ""));
        var geometry = new THREE.PlaneGeometry(100, 100);
        var material = new THREE.MeshLambertMaterial( { color: color, side: THREE.DoubleSide,
            transparent: true, opacity: 1.0} );
        var plane = new THREE.Mesh( geometry, material );
        plane.castShadow = true;
        plane.receiveShadow = true;
        objects[objects_count] = plane;
        selected_object = objects_count;
        objects_count++;
        scene.add( plane );
        control.attach( plane );
        render();
    }

    /*
     * Add a new cylinder to the scene
     */
    function addCylinder(){
        var color = new THREE.Color();
        color.setHex("0x" + ($("#objColor").val()).replace("#", ""));
        var geometry = new THREE.CylinderGeometry(100, 100, 100);
        var material = new THREE.MeshLambertMaterial( { color: color,
            transparent: true, opacity: 1.0} );
        var cylinder = new THREE.Mesh( geometry, material );
        cylinder.castShadow = true;
        cylinder.receiveShadow = true;
        objects[objects_count] = cylinder;
        selected_object = objects_count;
        objects_count++;
        scene.add( cylinder );
        control.attach( cylinder );
        render();
    }

    //------------------------------------------------------Text------------------------------------------------------
    /*
     * Add a new text mesh to the scene
     */
    function addText() {
        //Get selected colors
        var colorText = new THREE.Color();
        colorText.setHex("0x" + ($("#textColor").val()).replace("#", ""));
        var colorTextOut = new THREE.Color();
        colorTextOut.setHex("0x" + ($("#textColorOut").val()).replace("#", ""));

        var loader = new THREE.FontLoader();
        var materialFront = new THREE.MeshBasicMaterial( { color: colorText } );
        var materialSide = new THREE.MeshBasicMaterial( { color: colorTextOut } );
        var materialArray = [ materialFront, materialSide ];

        //Imported fonts contains weight in its name; we don't add it is so
        var finalfontname;
        console.log("fname : " + fontName);
        if (fontName.includes('regular') || fontName.includes('bold'))
            finalfontname = fontName + ".typeface.json";
        else
            finalfontname = fontName + "_" + fontWeight + ".typeface.json";
        //Then load the font and create text object
        loader.load( "fonts/" + finalfontname, function ( font ) {
            var geometry = new THREE.TextGeometry( $("#textToAdd").val(), {
                font: font,
                size: 80,
                height: 5,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 10,
                bevelSize: 8,
                bevelOffset: 0,
                bevelSegments: 5
            } );
            var textMesh = new THREE.Mesh(geometry, materialArray );

            //geometry.computeBoundingBox();
            objects[objects_count] = textMesh;
            selected_object = objects_count;
            objects_count++;
            scene.add(textMesh);
            control.attach( textMesh );
            render();
        } );
    }

    /*
     * Change selected font
     */
    function changeFont(){
        fontName = $("#fonts").val();
    }

    /*
     * Change selected font weight
     */
    function changeFontWeight(){
        if ($("#fontWeight").is(":checked"))
            fontWeight = "bold";
        else fontWeight = "regular";
    }

    //------------------------------------------------------Controls------------------------------------------------------
    /*
     * Switch transform control to the next object
     */
    function switchObjectControl(){
        if (objects_count === 0) return;
        if (selected_object === objects_count || selected_object === (objects_count - 1))
            selected_object = 0;
        else selected_object++;
            control.attach(objects[selected_object]);
    }

    /*
     * Remove current controlled object
     */
    function removeObject(){
        scene.remove(objects[selected_object]);
        objects.splice(selected_object, 1);
        objects_count--;
        if (objects_count === 0){
            control.detach();
            selected_object = null;
        }
        else {
            selected_object = 0;
            control.attach(objects[selected_object]);
        }
        render();
    }

    //------------------------------------------------------Basic operations------------------------------------------------------
    /*
     * Change object's color
     */
    function changeColor(){
        var color = "0x" + ($("#objColor").val()).replace("#", "");
        if (selected_object !== null) {
            objects[selected_object].material.color.setHex(color);
            render();
        }
    }

    /*
     * Change object's opacity
     */
    function changeOpacity() {
        var opacity = $("#objOpacity").val();
        if (selected_object !== null) {
            //If its a basic mesh
            if (objects[selected_object] instanceof THREE.Mesh){
                objects[selected_object].material.opacity = opacity;
            }
            else {
                //If its an imported object
                objects[selected_object].traverse( function (child) {
                    if (child instanceof THREE.Mesh) {
                        child.material.opacity = opacity;
                        child.material.transparent = true;
                    }
                });
            }
            render();
        }
    }

    //------------------------------------------------------Drag&Drop Handlers------------------------------------------------------
    /*
     * Drop file in object import zone
     */
    function dropHandlerObject(ev) {
        $("#dropText").fadeIn(500);
        //Prevent default behavior (Prevent file from being opened)
        ev.preventDefault();
        if (ev.dataTransfer.items) {
            //Use DataTransferItemList interface to access the file(s)
            for (var i = 0; i < ev.dataTransfer.items.length; i++) {
                //If dropped items aren't files, reject them
                if (ev.dataTransfer.items[i].webkitGetAsEntry().isDirectory) {
                    showPopupForMilliSeconds("dropZone", "Veuillez mettre uniquement des fichiers.", 4000, false);
                    return;
                }
                if (ev.dataTransfer.items[i].kind !== 'file') {
                    showPopupForMilliSeconds("dropZone", "Veuillez mettre uniquement des fichiers.", 4000, false);
                    return;
                }
            }

            //showPopupForMilliSeconds("dropZoneObject", "File(s) are uploading...", 4000);
            $("#dropZoneObject").popover({"content" : "Uploading du fichier..", "trigger" : "manual"});
            $("#dropZoneObject").popover('show');
            //Upload files on server and load the object in the scene
            uploadFilesOnServerAndLoad(ev.dataTransfer.items);
        }
    }

    /*
     * Drop file in font import zone
     */
    function dropHandlerFont(ev){
        $("#dropTextFont").fadeIn(500);
        //Prevent default behavior (Prevent file from being opened)
        ev.preventDefault();
        if (ev.dataTransfer.items) {
            var filename = ev.dataTransfer.items[0].getAsFile().name;
            //Check if file is JSON
            if (filename.toLowerCase().includes(".json")){
                //Download font to server
                var fdata = new FormData();
                fdata.append("files[]", ev.dataTransfer.items[0].getAsFile());
                fetch(storeFontURL, {
                    method: 'POST',
                    body: fdata,
                }).then(response => {
                    if (response.ok) {
                        //Add font to list
                        $("#fonts").append('<option value="' + filename.split(".")[0].toLowerCase() + '">'
                            + filename.split(".")[0].toLowerCase() + '</option>');
                        showPopupForMilliSeconds("dropZoneFont", "Police ajoutée.", 4000, false);
                    }
                });
            }
        }
    }

    /*
     * Prevent browser's default drop event
     */
    function dragOverHandlerObject(ev) {
        $("#dropText").fadeOut(500);
        // Prevent default behavior (Prevent file from being opened)
        ev.preventDefault();
    }
    function dragOverHandlerFont(ev) {
        $("#dropTextFont").fadeOut(500);
        // Prevent default behavior (Prevent file from being opened)
        ev.preventDefault();
    }

    /*
     * Drag leave zone
     */
    function dragLeaveHandlerObject(){
        $("#dropText").fadeIn(500);
    }
    function dragLeaveHandlerFont(){
        $("#dropTextFont").fadeIn(500);
    }

    //------------------------------------------------------Object load functions------------------------------------------------------
    /*
     * Load the uploaded FBX object to the scene
     */
    function LoadFBXObject() {
        // model
        var loader = new THREE.FBXLoader();
        console.log("loader");
        loader.load('3dObjects/temp/' + lastUploadedObjectName.split(".")[0] + '/' + lastUploadedObjectName,
            function (object){
            /*object.traverse( function ( child ) {
                if ( child.isMesh ) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            } );*/
            console.log("Loaded");
            objects[objects_count] = object;
            selected_object = objects_count;
            objects_count++;
            scene.add( object );
            control.attach(object);
            object.scale.set(10, 10, 10,);
            //Remove files when object is on scene
            removeTempFolder();
            render();
        },
        function ( error ) {
            $("#dropZoneObject").popover('dispose');
            showPopupForMilliSeconds("dropZone", "Erreur lors du chargement :" + error, 10000, false);
            console.log(error);
        });
    }

    /*
     * Load the uploaded glTF object to the scene
     */
    function LoadGLTFObject(){
        // Instantiate a loader and set path to temp folder
        var loader = new THREE.GLTFLoader().setPath( '3dObjects/temp/' + lastUploadedObjectName.split(".")[0] + '/');
        console.log("Path set");
        // Load a glTF resource
        loader.load( lastUploadedObjectName, function ( gltf ) {
                gltf.scene.traverse( function ( child ) {
                    if ( child.isMesh ) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                } );
                console.log("Loaded");
                objects[objects_count] = gltf.scene;
                selected_object = objects_count;
                objects_count++;
                scene.add( gltf.scene );
                control.attach(gltf.scene);
                gltf.scene.scale.set(10, 10, 10,);
                //Remove files when object is on scene
                removeTempFolder();
                render();
            },
            // called while loading is progressing
            function ( xhr ) {
                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

            },
            // called when loading has errors
            function ( error ) {
                $("#dropZoneObject").popover('dispose');
                showPopupForMilliSeconds("dropZone", "Erreur lors du chargement :" + error, 10000, false);
            }
        );
    }

    /*
     * Load the uploaded OBJ object to the scene
     */
    function LoadOBJObject() {
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setResourcePath('3dObjects/temp/' + lastUploadedObjectName.split(".")[0] + '/');
        mtlLoader.setPath('3dObjects/temp/' + lastUploadedObjectName.split(".")[0] + '/');
        mtlLoader.load(lastUploadedObjectName.split(".")[0] + '.mtl', function (materials) {
            materials.preload();
            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('3dObjects/temp/' + lastUploadedObjectName.split(".")[0] + '/');
            objLoader.load(lastUploadedObjectName, function (object) {
                objects[objects_count] = object;
                selected_object = objects_count;
                objects_count++;
                scene.add(object);
                object.scale.set(10, 10, 10,);
                control.attach(object);
                //Remove files when object is on scene
                removeTempFolder();
                render();
            });
        });
    }

    //------------------------------------------------------Utils functions------------------------------------------------------
    /*
    * Upload the dropped files on the server in the temp folder
    * by calling the php script
    * @param files : the list of the files to upload
    */
    function uploadFilesOnServerAndLoad(files) {
        var fdata = new FormData();
        var format;
        for (var i = 0; i < files.length; i++){
            var f = files[i].getAsFile();
            fdata.append("files[]", f);
        }
        //Get object format and name
        format = getDroppedFilesFormat(files);
        lastUploadedObjectName = getDroppedFilesObjectName(files);
        fdata.append("folder", lastUploadedObjectName.split(".")[0]);
        fetch(storeFileURL, {
            method: 'POST',
            body: fdata,
        }).then(response => {
            if (response.ok){
                $("#dropZoneObject").popover('dispose');
                showPopupForMilliSeconds("dropZone", "Fichier uploadé. Chargement de l'objet..", 3000, false);
                //Load model into scene when uploaded
                switch (format) {
                    case "fbx": LoadFBXObject();
                        break;
                    case "obj": LoadOBJObject();
                        break;
                    case "gltf": LoadGLTFObject();
                        break;
                }
            }
            else {
                $("#dropZoneObject").popover('dispose');
                showPopupForMilliSeconds("dropZone", "Erreur lors de l'upload", 4000, false);
            }
        });
    }
    /*
     * Returns the dropped object's format
     * @param files : the list of the files
     */
    function getDroppedFilesFormat(files){
        for (var i = 0; i < files.length; i++){
            var f = files[i].getAsFile().name.toLowerCase();
            if (f.includes(".fbx"))
                return "fbx";
            else if (f.includes(".obj"))
                return "obj";
            else if (f.includes(".glb") || f.includes(".gltf"))
                return "gltf";
        }
        return null;
    }

    /*
     * Returns the file's name of the object
     * @param files : the list of the files
     */
    function getDroppedFilesObjectName(files){
        for (var i = 0; i < files.length; i++){
            var f = files[i].getAsFile().name.toLowerCase();
            if (f.includes(".fbx") || f.includes(".obj") ||
                f.includes(".glb") || f.includes(".gltf")){
                return f;
            }
        }
    }

    /*
     * Remove the temp folder containing loaded object
     */
    function removeTempFolder(){
        var fdata = new FormData();
        fdata.append("folder", lastUploadedObjectName.split(".")[0]);
        fetch(removeFileURL, {
            method: 'POST',
            body: fdata,
        }).then(response => {
            if (!response.ok){
                $("#dropZoneObject").popover('dispose');
                showPopupForMilliSeconds("dropZone", "Erreur lors de l'effacement du fichier temp", 4000, false);
            }
        });
    }

    /*
     * Create and show a popover for a selected time
     * @param zone : the html component to attach the popover
     * @param text : the popover text
     * @param time : the time in ms before hiding the popover
     * @param html : if the text contains html code to be interpreted
     */
    function showPopupForMilliSeconds(zone, text, time, html){
        $("#" + zone).popover({"content" : text, "trigger" : "manual", "html" : html});
        $("#" + zone).popover('show');
        window.setTimeout(hidePopover, time);

        function hidePopover() {
            $("#" + zone).popover('hide');
        }
    }

    /*
     * Toogle the popover of the import instructions (warning buttons)
     */
    function toggleImportWarningPopover(){
        var text = 'Les dossiers ne sont pas supportés, ne placez que des fichiers. ' +
            'Si besoin, modifier les fichiers .gltf ou .mtl pour supprimer le chemin vers les textures et ne garder ' +
            'que les noms des textures.\nL\'éventuel fichier .mtl doit être nommé avec le même nom que le fichier .obj.' +
            '\nLes textures 3dsMax | maps | texmap_diffuse map ne sont pas supportées.';
        showPopupForMilliSeconds("importWarningButton", text, 7500, false);
    }
    function toggleImportFontWarningPopover(){
        var text = 'Le fichier de police doit être au format JSON. Il est possible de convertir ' +
            'un fichier de police classique à cette adresse : ' +
            "<a href='https://gero3.github.io/facetype.js'>https://gero3.github.io/facetype.js/</a>";
        showPopupForMilliSeconds("importFontWarningButton", text, 7000, true);
    }

    //------------------------------------------------------Windows events------------------------------------------------------
    /*
     * Windows quit event : remove imported fonts
     */
    window.onbeforeunload = function (e) {
        var fdata = new FormData();
        fetch(removeFontsURL, {
            method: 'POST',
            body: fdata,
        });
    };

    /*
     * Windows resize event : resize render canvas
     */
    window.addEventListener( 'resize', onWindowResize, false );
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        render();
    }

</script>
<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>
</html>