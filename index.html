<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Objectselector Creator</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="style/style.css" type="text/css">
</head>
<body>
<div id="control">
    <a href="javascript:control.setMode( 'translate' );">"W" translate</a> |
    <a href="javascript:control.setMode( 'rotate' );">"E" rotate</a> |
    <a href="javascript:control.setMode( 'scale' );">"R" scale</a> |
    <a href="javascript:control.setSpace( control.space === 'local' ? 'world' : 'local' );">
        "Q" toggle world/local space</a><br />
    <a href="javascript:switchObjectControl();">"T" switch object control</a> |
    Hold "Ctrl" down to snap to grid |
    <a href="javascript:removeObject();">"X" remove</a>
</div>
<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/TransformControls.js"></script>
<script src="js/GLTFLoader.js"></script>
<script src="js/OBJLoader.js"></script>
<script src="js/FBXLoader.js"></script>
<script src="js/GeometryUtils.js"></script>
<script src="js/inflate.min.js"></script>
<script src="js/MTLLoader.js"></script>
<script src="js/GLTFExporter.js"></script>
<script src="js/classes.js"></script>

<nav class="navbar navbar-expand-lg navbar-light bg-light" id="navbar">
    <span class="navbar-brand">Ajout d'objets</span>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                    Ajouter
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="#" id="addPrefabBanner" onclick="addPremadeObject(1);">Bannière</a>
                    <a class="dropdown-item" href="#" onclick="addPremadeObject(2);">Capsule</a>
                    <a class="dropdown-item" href="#" onclick="addPremadeObject(3);">Texte défilant</a>
                    <a class="dropdown-item" href="#" onclick="addPremadeObject(4);">Texte circulaire</a>
                    <div class="dropdown-divider"></div>
                </div>
            </li>
            <form class="form-inline" style="margin-left:20px;">
                <button class="btn btn-sm btn-outline-secondary" type="button" onclick="toggleAdvancedControls();">
                    Montrer contrôles avancés
                </button>
            </form>
            <form class="form-inline" style="margin-left: 20px;">
                <button class="btn btn-success" type="button" onclick="exportSceneToGLB();">
                    Valider objet
                </button>
            </form>
        </ul>
    </div>
</nav>

<div id="panel" class="container">
    <div id="importZone">
        <h5>Glisser & déposer
            <button id="importWarningButton" type="button" class="btn btn-warning btn-sm" onclick="toggleImportWarningPopover();">
                Instructions
            </button>
        </h5>
        <div id="dropZoneObject" ondrop="dropHandlerObject(event);" ondragover="dragOverHandlerObject(event);"
             ondragleave="dragLeaveHandlerObject();">
            <p id="dropTextObject">Importer objet 3D FBX, OBJ ou glTF/glb (modèle et textures)<br/> Ou police de charactères (format JSON)</p>
        </div>
        <!-- <h5>Importer police
            <button id="importFontWarningButton" type="button" class="btn btn-warning btn-sm" onclick="toggleImportFontWarningPopover();">
                Warning
            </button>
        </h5>
        <div id="dropZoneFont" ondrop="dropHandlerFont(event);" ondragover="dragOverHandlerFont(event);"
             ondragleave="dragLeaveHandlerFont();">
            <p id="dropTextFont">Importer police (Fichier JSON)</p>
        </div> -->
    </div>

    <div id="options">
        Options de l'objet
        <div id="optionColor">
            <h5>Modifier couleur</h5>
            <input type="color" id="objColor" name="objColor"
                   value="#00ff00" onchange="changeColor();">
            <label for="objColor">Couleur</label>
        </div>

        <div id="optionText">
            <h5>Modifier texte</h5>
            <label for="fonts">Police</label>
            <select id="fonts" onchange="changeFont();">
                <option value="helvetiker">helvetiker</option>
                <option value="optimer">optimer</option>
                <option value="gentilis">gentilis</option>
                <option value="droid_sans">droid sans</option>
                <option value="droid_serif">droid serif</option>
            </select>
            <input type="checkbox" id="fontWeight" onchange="changeFontWeight();"> Gras<br/>
            <input type="color" id="textColor" name="objColor"
                   value="#ff0000" onchange="changeColorTextIn();">
            <label for="textColor">Couleur texte</label>
            <input type="color" id="textColorOut" name="objColor"
                   value="#0000ff" onchange="changeColorTextOut();">
            <label for="textColorOut">Couleur contours</label>
        </div>

        <div id="optionOpacity">
            <h5>Modifier transparence</h5>
            0<input type="range" id="objOpacity" min="0" max="1" step="0.0001"
                    value="#00ff00" oninput="changeOpacity();">1
            <label for="objOpacity">Opacité</label>
        </div>
    </div>

    <div id="optionAnimation">
        <h5>Animer l'objet</h5>
        <input type="checkbox" id="animRotate" onchange="setAnim(1);">
        <label for="animRotate">Rotation</label>
        <input type="checkbox" id="animFloat" onchange="setAnim(2);">
        <label for="animFloat">Flottement</label>
    </div>

    <!-- <h5>Importer texture</h5>
    <div id="dropZoneTexture" ondrop="dropHandlerTexture(event);" ondragover="dragOverHandlerTexture(event);"
         ondragleave="dragLeaveHandlerTexture();">
        <p id="dropTextTexture">Glissez et déposez le fichier JPG ou PNG</p>
    </div> -->
    <div id="advancedControls">
        <b style="color: grey;">Contrôles avancés</b>
        <h4>Ajouter forme</h4>
        <button onclick="addCube();">Cube</button>
        <button onclick="addPlane();">Plan</button>
        <button onclick="addCylinder();">Cylindre</button><br/>
        <h4 style="margin-top: 10px;">Ajouter texte</h4>
        <label for="textToAdd">Texte</label>
        <input type="text" id="textToAdd">
        <button onclick="addText();">Ajouter</button><br/>
    </div>
</div>

<script>

    var camera, scene, renderer, control, orbit, light;
    //We keep track of all objects in the scene
    var objects = [];
    //We keep track of the object's type : basic, text, object, banner, ellipse, circulary, parade
    var myTypes = Object.freeze({"basic":1, "text":2, "importedObject":3, "banner":4, "ellipse":5, "circulary":6, "parade":7});
    var objects_types = [], objects_class = [];
    //Animation types of objects
    var objects_anim = [];
    var objects_count = 0;
    var selected_object = null;

    var fontName = "helvetiker", fontWeight = "regular" ;
    var lastUploadedObjectName = null, lastUploadedTextureName = null;
    var areAdvancedControlsToggled = false;

    var objectName = 'obj.glb';

    const tempStorePath = '3dObjects/temp/';
    const prefabStorePath = '3dObjects/prefabs';

    const storeFileURL = "storeFile.php";
    const removeFileURL = "removeFile.php";
    const storeFontURL = "storeFont.php";
    const removeFontsURL = "removeFonts.php";
    const storeTextureURL = "storeTexture.php";
    const removeTextureURL = "removeTexture.php";
    const storeObjectURL = "storeObject.php";
;
    init();
    render();

    //------------------------------------------------------Init & Render----------------------------------------------------------------------
    /*
     * Initalization function
     */
    function init() {
        //Create renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( (window.innerWidth / 2), (window.innerHeight - 20) );
        document.body.appendChild( renderer.domElement );
        //settings for gltf loading
        //renderer.gammaOutput = true;
        //renderer.gammaFactor = 2.2;

        //Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xbfbfbf );
        scene.add( new THREE.GridHelper( 1000, 10 ) );

        //Create camera
        camera = new THREE.PerspectiveCamera( 50, (window.innerWidth / 2) / (window.innerHeight - 20), 1, 5000 );
        camera.position.set( 1000, 500, 1000 );
        camera.lookAt( 0, 200, 0 );

        //Create light
        light = new THREE.DirectionalLight( 0xffffff, 2 );
        light.position.set( 1, 1, 1 );
        scene.add( light );

        //Create space controls
        orbit = new THREE.OrbitControls( camera, renderer.domElement );
        orbit.update();
        orbit.addEventListener( 'change', render );

        //Create object controls
        control = new THREE.TransformControls( camera, renderer.domElement );
        control.addEventListener( 'change', render );
        control.addEventListener( 'dragging-changed', function ( event ) {
            orbit.enabled = ! event.value;
        } );
        scene.add( control );

        //Object controls modes
        window.addEventListener( 'keydown', function ( event ) {
            switch ( event.keyCode ) {
                case 81: // Q
                    control.setSpace( control.space === "local" ? "world" : "local" );
                    break;
                case 17: // Ctrl
                    control.setTranslationSnap( 20 );
                    control.setRotationSnap( THREE.Math.degToRad( 15 ) );
                    break;
                case 87: // W
                    control.setMode( "translate" );
                    break;
                case 69: // E
                    control.setMode( "rotate" );
                    break;
                case 82: // R
                    control.setMode( "scale" );
                    break;
                case 85: // T
                    switchObjectControl();
                    break;
                case 88: // X
                    removeObject();
                    break;
            }
        } );
        window.addEventListener( 'keyup', function ( event ) {
            switch ( event.keyCode ) {
                case 17: // Ctrl
                    control.setTranslationSnap( null );
                    control.setRotationSnap( null );
                    break;
            }
        } );
    }

    /*
     * Render function
     */
    function render() {
        requestAnimationFrame( render );

        for (var i = 0; i < objects_anim.length; i++){
            switch (objects_anim[i]) {
                case 1:
                    objects[i].rotation.y += 0.01;
                    break;
            }
        }
        renderer.render( scene, camera );
    }

    //------------------------------------------------------objects spawning----------------------------------------------------------------------
    /*
     * Add a new cube to the scene
     */
    function addCube() {
        var color = new THREE.Color();
        color.setHex("0x" + ($("#objColor").val()).replace("#", ""));
        var geometry = new THREE.BoxGeometry(100, 100, 100);
        var material = new THREE.MeshLambertMaterial( { color: color,
            transparent: true, opacity: 1.0} );
        var cube = new THREE.Mesh( geometry, material );
        cube.castShadow = true;
        cube.receiveShadow = true;
        //Add object to arrays and scene
        addNewObjectToProject(cube, myTypes.basic);
    }

    /*
     * Add a new plane to the scene
     */
    function addPlane() {
        var color = new THREE.Color();
        color.setHex("0x" + ($("#objColor").val()).replace("#", ""));
        var geometry = new THREE.PlaneGeometry(100, 100);
        var material = new THREE.MeshLambertMaterial( { color: color, side: THREE.DoubleSide,
            transparent: true, opacity: 1.0} );
        var plane = new THREE.Mesh( geometry, material );
        plane.castShadow = true;
        plane.receiveShadow = true;
        //Add object to arrays and scene
        addNewObjectToProject(plane, myTypes.basic);
    }

    /*
     * Add a new cylinder to the scene
     */
    function addCylinder(){
        var color = new THREE.Color();
        color.setHex("0x" + ($("#objColor").val()).replace("#", ""));
        var geometry = new THREE.CylinderGeometry(100, 100, 100);
        var material = new THREE.MeshLambertMaterial( { color: color,
            transparent: true, opacity: 1.0} );
        var cylinder = new THREE.Mesh( geometry, material );
        cylinder.castShadow = true;
        cylinder.receiveShadow = true;
        //Add object to arrays and scene
        addNewObjectToProject(cylinder, myTypes.basic);
    }

    //------------------------------------------------------Text spawning----------------------------------------------------------------------
    /*
     * Add a new text mesh to the scene
     */
    function addText() {
        //Get selected colors
        var colorText = new THREE.Color();
        colorText.setHex("0x" + ($("#textColor").val()).replace("#", ""));
        var colorTextOut = new THREE.Color();
        colorTextOut.setHex("0x" + ($("#textColorOut").val()).replace("#", ""));

        var loader = new THREE.FontLoader();
        var materialFront = new THREE.MeshBasicMaterial( { color: colorText } );
        var materialSide = new THREE.MeshBasicMaterial( { color: colorTextOut } );
        var materialArray = [ materialFront, materialSide ];

        //Imported fonts contains weight in its name; we don't add it is so
        var finalfontname;
        console.log("fname : " + fontName);
        if (fontName.includes('regular') || fontName.includes('bold'))
            finalfontname = fontName + ".typeface.json";
        else
            finalfontname = fontName + "_" + fontWeight + ".typeface.json";
        //Then load the font and create text object
        loader.load( "fonts/" + finalfontname, function ( font ) {
            var geometry = new THREE.TextGeometry( $("#textToAdd").val(), {
                font: font,
                size: 80,
                height: 5,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 10,
                bevelSize: 8,
                bevelOffset: 0,
                bevelSegments: 5
            } );
            var textMesh = new THREE.Mesh(geometry, materialArray );

            //geometry.computeBoundingBox();
            //Add object to arrays and scene
            addNewObjectToProject(textMesh, myTypes.text);
        } );
    }

    /*
     * Change selected font
     */
    function changeFont(){
        switch (objects_types[selected_object]) {
            case myTypes.text:
                fontName = $("#fonts").val();
                refreshText(false, false);
                break;

            case myTypes.banner:
                var fname= $("#fonts").val().trim() + '_' + fontWeight;
                objects_class[selected_object].changeTextFont(fname, scene);
                render();
                break;
        }
    }

    /*
     * Change selected font weight
     */
    function changeFontWeight(){
        if (isFontBasic()){
            if ($("#fontWeight").is(":checked"))
                fontWeight = "bold";
            else fontWeight = "regular";
            refreshText(false, false);
        }
    }

    /*
     * Change selected inner text color
     */
    function changeColorTextIn(){
        switch (objects_types[selected_object]) {
            case myTypes.text:
                refreshText(true, false);
                break;
            case myTypes.banner:
                objects_class[selected_object].changeTextColor(
                    new THREE.Color().setHex("0x" + ($("#textColor").val()).replace("#", "")), true);
                render();
                break;
        }
    }

    /*
     * Change selected outer text color
     */
    function changeColorTextOut(){
        switch (objects_types[selected_object]) {
            case myTypes.text:
                refreshText(false, true);
                break;
            case myTypes.banner:
                objects_class[selected_object].changeTextColor(
                    new THREE.Color().setHex("0x" + ($("#textColorOut").val()).replace("#", "")), false);
                render();
                break;
        }
    }

    /*
     * Recreate a existing text with new color, font or weight
     */
    function refreshText(changeColorIn, changeColorOut){
        //Get new colors if wanted
        if (changeColorIn){
            var colorText = new THREE.Color();
            colorText.setHex("0x" + ($("#textColor").val()).replace("#", ""));
            //Retrieve old color
            var colorTextOut = objects[selected_object].material[1].color;

        }
        else
        if (changeColorOut) {
            var colorTextOut = new THREE.Color();
            colorTextOut.setHex("0x" + ($("#textColorOut").val()).replace("#", ""));
            //Retrieve old color
            var colorTextIn = objects[selected_object].material[0].color;
        }
        else {
            //Get actual text colors
            var colorTextIn = objects[selected_object].material[0].color;
            var colorTextOut = objects[selected_object].material[1].color;
        }

        var loader = new THREE.FontLoader();
        var materialFront = new THREE.MeshBasicMaterial( { color: colorTextIn } );
        var materialSide = new THREE.MeshBasicMaterial( { color: colorTextOut } );
        var materialArray = [ materialFront, materialSide ];

        //Imported fonts contains weight in its name; we don't add it is so
        var finalfontname;
        console.log("fname : " + fontName);
        if (fontName.includes('regular') || fontName.includes('bold'))
            finalfontname = fontName + ".typeface.json";
        else
            finalfontname = fontName + "_" + fontWeight + ".typeface.json";
        //Then load the font and create text object
        loader.load( "fonts/" + finalfontname, function ( font ) {
            var geometry = new THREE.TextGeometry( $("#textToAdd").val(), {
                font: font,
                size: 80,
                height: 5,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 10,
                bevelSize: 8,
                bevelOffset: 0,
                bevelSegments: 5
            } );
            var textMesh = new THREE.Mesh(geometry, materialArray );

            //Put new text in the same position/rotation as the old one
            textMesh.position.copy(objects[selected_object].position);
            textMesh.rotation.copy(objects[selected_object].rotation);
            textMesh.scale.copy(objects[selected_object].scale);
            //geometry.computeBoundingBox();
            //remove old object
            scene.remove(objects[selected_object]);
            //Update object in array
            objects[selected_object] = textMesh;
            //Add to scene and control
            scene.add(textMesh);
            control.attach( textMesh );
            showControlledObjectOptions();
            render();
        } );
    }

    /*
     * Check if the selected font is one of the basic proposed
     */
    function isFontBasic(){
        if (fontName === "helvetiker" || fontName === "optimer" ||
            fontName === "gentilis" || fontName === "droid_sans" ||
            fontName === "droid_serif")
            return true;
        else return false;
    }
    //------------------------------------------------------Premade objects spawning----------------------------------------------------------------------
    /*
     * Add a premade object to the scene (see classes)
     */
    function addPremadeObject(which){
        switch (which) {
            //Banner
            case 1:
                bootbox.prompt("Entrez le texte à afficher", function(text) {
                    var banner = new Banner(text);
                    banner.createBanner().then(
                        function(group){
                            //Add object to arrays
                            addNewObjectToProject(group, myTypes.banner);
                            objects_class[selected_object] = banner;
                        }
                    );
                });
            break;
            //Ellipse
            case 2:
                bootbox.prompt("Entrez le texte à afficher", function(text) {
                    var capsule = new Ellipse(text);
                    capsule.createEllipse().then(
                        function(group){
                            //Add object to arrays
                            addNewObjectToProject(group, myTypes.ellipse);
                            objects_class[selected_object] = capsule;
                        }
                    );
                });
            break;
        }
        render();
    }
    //------------------------------------------------------Animation----------------------------------------------------------------------

    function setAnim(which){
        switch (which) {
            case 1:
                if (document.getElementById('animRotate').checked){
                    objects_anim[selected_object] += 1;
                }
                else {
                    objects_anim[selected_object] -= 1;
                }
            break;
                if (document.getElementById('animFloat').checked){
                    objects_anim[selected_object] += 2;
                }
                else {
                    objects_anim[selected_object] -= 2;
                }
            case 2:
            break;
        }
    }

    //------------------------------------------------------Controls----------------------------------------------------------------------
    /*
     * Switch transform control to the next object and show options
     */
    function switchObjectControl(){
        //Switch controls to next object
        if (objects_count === 0) return;
        if (selected_object === objects_count || selected_object === (objects_count - 1))
            selected_object = 0;
        else selected_object++;
            control.attach(objects[selected_object]);

        showControlledObjectOptions();

    }

    /*
     * Remove current controlled object
     */
    function removeObject(){
        scene.remove(objects[selected_object]);
        objects.splice(selected_object, 1);
        objects_count--;
        if (objects_count === 0){
            control.detach();
            selected_object = null;
        }
        else {
            selected_object = 0;
            control.attach(objects[selected_object]);
        }
        showControlledObjectOptions();
        render();
    }

    /*
     * Toggle advanced control panel (basic forms, text)
     */
    function toggleAdvancedControls() {
        if (!areAdvancedControlsToggled){
            areAdvancedControlsToggled = true;
            $("#toggleAdvanced").html("Cacher contrôles avancés");
            $("#advancedControls").show();
        }
        else{
            areAdvancedControlsToggled = false;
            $("#toggleAdvanced").html("Montrer contrôles avancés");
            $("#advancedControls").hide();
        }
    }

    /*
     * Show selected object options
     */
    function showControlledObjectOptions(){
        //Hide everything then show the right options
        hideAllOptions();
        switch (objects_types[selected_object]) {
            case myTypes.basic:
                $("#optionColor").show();
                $("#optionOpacity").show();
                break;
            case myTypes.text:
                $("#optionText").show();
                break;
            case myTypes.importedObject:
                $("#optionOpacity").show();
                break;
            case myTypes.banner:
                $("#optionColor").show();
                $("#optionOpacity").show();
                $("#optionTextBanner").show();
                $("#optionText").show();
                break;
        }
    }

    /*
     * Hide all options
     */
    function hideAllOptions(){
        $("#optionColor").hide();
        $("#optionOpacity").hide();
        $("#optionText").hide();
    }

    //------------------------------------------------------Basic operations----------------------------------------------------------------------
    /*
     * Change object's color
     */
    function changeColor(){
        var color = "0x" + ($("#objColor").val()).replace("#", "");
        switch (objects_types[selected_object]) {
            case myTypes.basic:
                objects[selected_object].material.color.setHex(color);
                break;
            case myTypes.banner:
                objects_class[selected_object].changePlaneColor(color);
                break;
        }
        render();
    }

    /*
     * Change object's opacity
     */
    function changeOpacity() {
        var opacity = $("#objOpacity").val();
        if (selected_object !== null) {
            //If its a basic mesh
            if (objects[selected_object] instanceof THREE.Mesh){
                objects[selected_object].material.opacity = opacity;
            }
            else {
                //If its an imported object
                objects[selected_object].traverse( function (child) {
                    if (child instanceof THREE.Mesh) {
                        child.material.opacity = opacity;
                        child.material.transparent = true;
                    }
                });
            }
            render();
        }
    }

    //------------------------------------------------------Drag&Drop Handlers----------------------------------------------------------------------
    /*
     * Drop files in object import zone
     */
    function dropHandlerObject(ev) {
        //Prevent default behavior (Prevent file from being opened)
        ev.preventDefault();
        if (ev.dataTransfer.items) {
            //Use DataTransferItemList interface to access the file(s)
            for (var i = 0; i < ev.dataTransfer.items.length; i++) {
                //If dropped items aren't files, reject them
                if (ev.dataTransfer.items[i].webkitGetAsEntry().isDirectory) {
                    showPopupForMilliSeconds("dropZoneObject", "Veuillez mettre uniquement des fichiers.", 4000, false);
                    return;
                }
                if (ev.dataTransfer.items[i].kind !== 'file') {
                    showPopupForMilliSeconds("dropZoneObject", "Veuillez mettre uniquement des fichiers.", 4000, false);
                    return;
                }
            }
            //showPopupForMilliSeconds("dropZoneObject", "File(s) are uploading...", 4000);
            $("#dropZoneObject").popover({"content" : "Uploading du fichier..", "trigger" : "manual"});
            $("#dropZoneObject").popover('show');
            //Upload files on server and load the object in the scene
            uploadFilesOnServerAndLoad(ev.dataTransfer.items);
        }
        $("#dropZoneObject").css('background', 'white');
    }

    /*
     * Drop file in font import zone
     */
   /* function dropHandlerFont(ev){
        //Prevent default behavior (Prevent file from being opened)
        ev.preventDefault();
        $("#dropTextFont").fadeIn(500);
        if (ev.dataTransfer.items) {
            var filename = ev.dataTransfer.items[0].getAsFile().name;
            //Check if file is JSON
            if (filename.toLowerCase().includes(".json")){

            }
            else {
                showPopupForMilliSeconds("dropZoneFont", "Veuillez mettre un fichier de police JSON.", 3000, false);
            }
        }
    }*/

    /*
     * Drop files in texture import zone
     */
    /*function dropHandlerTexture(ev){
        //Prevent default behavior (Prevent file from being opened)
        ev.preventDefault();
        $("#dropTextTexture").fadeIn(500);
        if (ev.dataTransfer.items) {
            var filename = ev.dataTransfer.items[0].getAsFile().name;
            //Check if file is JSON
            if (filename.toLowerCase().includes(".png") || filename.toLowerCase().includes(".jpg")
                    || filename.toLowerCase().includes(".jpeg")){
                lastUploadedTextureName = filename.toLowerCase();
                //Download texture to server
                var fdata = new FormData();
                fdata.append("files[]", ev.dataTransfer.items[0].getAsFile());
                fetch(storeTextureURL, {
                    method: 'POST',
                    body: fdata,
                }).then(response => {
                    if (response.ok) {
                        //Load texture to selected object
                        LoadTextureToSelectedObject();
                    }
                });
            }
            else {
                showPopupForMilliSeconds("dropZoneFont", "Veuillez mettre un fichier JPG ou PNG.", 3000, false);
            }
        }
    }*/

    /*
     * Prevent browser's default drop event
     */
    function dragOverHandlerObject(ev) {
        $("#dropZoneObject").css('background', '#ffff99');
        // Prevent default behavior (Prevent file from being opened)
        ev.preventDefault();
    }

    /*
     * Drag leave zone
     */
    function dragLeaveHandlerObject(){
        $("#dropZoneObject").css('background', 'white');
    }

    //------------------------------------------------------Object load functions----------------------------------------------------------------------
    /*
     * Load the uploaded FBX object to the scene
     */
    function LoadFBXObject() {
        // model
        var loader = new THREE.FBXLoader();
        console.log("loader");
        loader.load(tempStorePath + lastUploadedObjectName.split(".")[0] + '/' + lastUploadedObjectName,
            function (object){
            /*object.traverse( function ( child ) {
                if ( child.isMesh ) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            } );*/
            console.log("Loaded");
            //add object to scene and array
            addNewObjectToProject(object, myTypes.importedObject);
            //Remove files when object is on scene
            removeTempFolder();
        },
        function ( error ) {
            $("#dropZoneObject").popover('dispose');
            showPopupForMilliSeconds("dropZoneObject", "Erreur lors du chargement :" + error, 10000, false);
            console.log(error);
        });
    }

    /*
     * Load the uploaded glTF object to the scene
     */
    function LoadGLTFObject(){
        // Instantiate a loader and set path to temp folder
        var loader = new THREE.GLTFLoader().setPath(tempStorePath + lastUploadedObjectName.split(".")[0] + '/');
        console.log("Path set");
        // Load a glTF resource
        loader.load( lastUploadedObjectName, function ( gltf ) {
                var objs = [];
                gltf.scene.traverse( function ( child ) {
                    if ( child.isMesh ) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                } );
                console.log("Loaded");
                //add object to scene and array
                addNewObjectToProject(gltf.scene, myTypes.importedObject);
                //Remove files when object is on scene
                removeTempFolder();
            },
            // called while loading is progressing
            function ( xhr ) {
                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

            },
            // called when loading has errors
            function ( error ) {
                $("#dropZoneObject").popover('dispose');
                showPopupForMilliSeconds("dropZoneObject", "Erreur lors du chargement :" + error, 10000, false);
            }
        );
    }

    /*
     * Load the uploaded OBJ object to the scene
     */
    function LoadOBJObject() {
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setResourcePath(tempStorePath + lastUploadedObjectName.split(".")[0] + '/');
        mtlLoader.setPath(tempStorePath + lastUploadedObjectName.split(".")[0] + '/');
        mtlLoader.load(lastUploadedObjectName.split(".")[0] + '.mtl', function (materials) {
            materials.preload();
            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath(tempStorePath + lastUploadedObjectName.split(".")[0] + '/');
            objLoader.load(lastUploadedObjectName, function (object) {
                //add object to scene and array
                addNewObjectToProject(object, myTypes.importedObject);
                //Remove files when object is on scene
                removeTempFolder();
            });
        });
    }

    /*
     * Export the builded object to GLB
     */
    function exportSceneToGLB(){
        // Instantiate a exporter
        var exporter = new THREE.GLTFExporter();
        //Check if there is a scene object in the objects array
        //getObjectsAsMeshes(objects);
        getObjectsAsMeshes(objects ,true);

        // Parse the input and generate the glTF output
        exporter.parse( final, function ( gltf ) {
            var file = new Blob( [ gltf ], { type: 'application/octet-stream' } );
            console.log( gltf );
            var fdata = new FormData();
            fdata.append("files[]", file);
            fetch(storeObjectURL, {
                method: 'POST',
                body: fdata,
            }).then(response => {
                if (response.ok) {
                    bootbox.alert("Objet exporté vers le server.", function(){
                        //Then redirect to map page
                        window.location = "/map.html?param=" + objectName;
                    });
                }
            });
        }, {binary : true} );
    }
    //------------------------------------------------------Utils functions-----------------------------------------------------------------------

    /*
    * Get all objects3D and meshes of the scene in an array
    * @param array : the global objects array
    */
    var final = [];
    function getObjectsAsMeshes(iterable, first) {
        console.log(iterable);
        if (first){
            for (var node of iterable) {
                if (node instanceof THREE.Object3D || node instanceof THREE.Scene
                    || node instanceof THREE.Group || node instanceof THREE.Mesh) {
                    if (/*node instanceof THREE.Object3D ||*/ node instanceof THREE.Scene || node instanceof THREE.Group)
                        getObjectsAsMeshes(node, false);
                    else {
                        final.push(node);
                    }
                }
            }
        }
        else
            iterable.traverse(function (node) {
                if (iterable !== node && (node instanceof THREE.Object3D || node instanceof THREE.Scene
                    || node instanceof THREE.Group || node instanceof THREE.Mesh)) {
                    if (/*node instanceof THREE.Object3D ||*/ node instanceof THREE.Scene|| node instanceof THREE.Group)
                        getObjectsAsMeshes(node, false);
                    else {
                        final.push(node);
                    }
                }
            });
        console.log(final);
    }

    /*
     * Add a new object to the scene and to the objects array
     * @param object : The mesh object to add to the scene and array
     * @param type : The object's myTypes type
     */
    function addNewObjectToProject(object, type){
        //Set object in global object array
        objects[objects_count] = object;
        //Set object type
        objects_types[objects_count] = type;
        //Init object animation array
        objects_anim[objects_count] = 0;
        selected_object = objects_count;
        objects_count++;
        //Add to scene and control
        scene.add( object );
        control.attach( object );
        showControlledObjectOptions();
        render();
    }

    /*
    * Upload the dropped files on the server in the temp folder
    * by calling the php script
    * @param files : the list of the files to upload
    */
    function uploadFilesOnServerAndLoad(files) {
        var fdata = new FormData();
        var format;
        for (var i = 0; i < files.length; i++){
            var f = files[i].getAsFile();
            fdata.append("files[]", f);
        }
        //Get object format
        format = getDroppedFilesFormat(files);
        //a font was dropped
        if (format === "json"){
            var filename = files[0].getAsFile().name;
            //Download font to server
            fdata = new FormData();
            fdata.append("files[]", files[0].getAsFile());
            fetch(storeFontURL, {
                method: 'POST',
                body: fdata,
            }).then(response => {
                if (response.ok) {
                    //Add font to list
                    $("#fonts").append('<option value="' + filename.split(".")[0].toLowerCase() + '">'
                        + filename.split(".")[0].toLowerCase() + '</option>');
                    $("#dropZoneObject").popover('dispose');
                    showPopupForMilliSeconds("dropZoneObject", "Police ajoutée.", 4000, false);
                }
            });
        }
        else{
            //an object was dropped
            lastUploadedObjectName = getDroppedFilesObjectName(files);
            fdata.append("folder", lastUploadedObjectName.split(".")[0]);
            fetch(storeFileURL, {
                method: 'POST',
                body: fdata,
            }).then(response => {
                if (response.ok){
                    $("#dropZoneObject").popover('dispose');
                    showPopupForMilliSeconds("dropZoneObject", "Fichier uploadé. Chargement de l'objet..", 3000, false);
                    //Load model into scene when uploaded
                    switch (format) {
                        case "fbx": LoadFBXObject();
                            break;
                        case "obj": LoadOBJObject();
                            break;
                        case "gltf": LoadGLTFObject();
                            break;
                    }
                }
                else {
                    $("#dropZoneObject").popover('dispose');
                    showPopupForMilliSeconds("dropZoneObject", "Erreur lors de l'upload", 4000, false);
                }
            });
        }
    }

    /*
     * Load the imported texture on the current selected object
     * won't work on imported objects
     */
    function LoadTextureToSelectedObject(){
        const loader = new THREE.TextureLoader();
        loader.load(tempStorePath + lastUploadedTextureName, (texture) => {
            const material = new THREE.MeshBasicMaterial({
                map: texture,
            });
                        //Check if object basic/text
            if (objects[selected_object] instanceof THREE.Mesh) {
                objects[selected_object].material.texture = texture;
                objects[selected_object].material.texture.needsUpdate = true;
                //Finally render and remove texture from server
                render();
                removeTempTexture();
            }
        });
    }

    /*
     * Returns the dropped object's format
     * @param files : the list of the files
     */
    function getDroppedFilesFormat(files){
        for (var i = 0; i < files.length; i++){
            var f = files[i].getAsFile().name.toLowerCase();
            if (f.includes(".fbx"))
                return "fbx";
            else if (f.includes(".obj"))
                return "obj";
            else if (f.includes(".glb") || f.includes(".gltf"))
                return "gltf";
            else if (f.includes(".json"))
                return "json";
        }
        return null;
    }

    /*
     * Returns the file's name of the object
     * @param files : the list of the files
     */
    function getDroppedFilesObjectName(files){
        for (var i = 0; i < files.length; i++){
            var f = files[i].getAsFile().name.toLowerCase();
            if (f.includes(".fbx") || f.includes(".obj") ||
                f.includes(".glb") || f.includes(".gltf")){
                return f;
            }
        }
    }

    /*
     * Remove the temp folder containing loaded object
     */
    function removeTempFolder(){
        var fdata = new FormData();
        fdata.append("folder", lastUploadedObjectName.split(".")[0]);
        fetch(removeFileURL, {
            method: 'POST',
            body: fdata,
        }).then(response => {
            if (!response.ok){
                $("#dropZoneObject").popover('dispose');
                showPopupForMilliSeconds("dropZoneObject", "Erreur lors de l'effacement du fichier temp", 4000, false);
            }
        });
    }

    /*
     * Remove the temp texture
     */
    function removeTempTexture(){
        var fdata = new FormData();
        fdata.append("name", lastUploadedTextureName);
        fetch(removeTextureURL, {
            method: 'POST',
            body: fdata,
        });
    }

    /*
     * Create and show a popover for a selected time
     * @param zone : the html component to attach the popover
     * @param text : the popover text
     * @param time : the time in ms before hiding the popover
     * @param html : if the text contains html code to be interpreted
     */
    function showPopupForMilliSeconds(zone, text, time, html){
        $("#" + zone).popover({"content" : text, "trigger" : "manual", "html" : html});
        $("#" + zone).popover('show');
        window.setTimeout(hidePopover, time);

        function hidePopover() {
            $("#" + zone).popover('hide');
        }
    }

    /*
     * Toogle the popover of the import instructions (warning buttons)
     */
    function toggleImportWarningPopover(){
        var text = "<h6>Objets 3D</h6>" + 'Les dossiers ne sont pas supportés, ne placez que des fichiers. ' +
            'Si besoin, modifier les fichiers .gltf ou .mtl pour supprimer le chemin vers les textures et ne garder ' +
            'que les noms des textures.\nL\'éventuel fichier .mtl doit être nommé avec le même nom que le fichier .obj.' +
            '\nLes textures map de 3dsMax ne sont pas supportées.' +
                "<h6>Police de charactères</h6>" + 'Le fichier de police doit être au format JSON. Il est possible de convertir ' +
            'un fichier de police classique à cette adresse : ' +
            "<a href='https://gero3.github.io/facetype.js'>https://gero3.github.io/facetype.js/</a>";
        showPopupForMilliSeconds("importWarningButton", text, 10000, true);
    }

    //------------------------------------------------------Windows events----------------------------------------------------------------------
    /*
     * Windows quit event : remove imported fonts
     */
    window.onbeforeunload = function (e) {
        var fdata = new FormData();
        fetch(removeFontsURL, {
            method: 'POST',
            body: fdata,
        });
    };

    /*
     * Windows resize event : resize render canvas
     */
    window.addEventListener( 'resize', onWindowResize, false );
    function onWindowResize() {
        camera.aspect = (window.innerWidth / 2) / (window.innerHeight - 20);
        camera.updateProjectionMatrix();
        renderer.setSize( (window.innerWidth / 2), (window.innerHeight - 20) );
        render();
    }

</script>
<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
<script src="js/bootbox.js"></script>
<script src="js/bootbox.locales.js"></script>
<script src="js/bootbox.all.js"></script>
</body>
</html>